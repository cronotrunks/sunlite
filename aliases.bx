#
#    This file is part of Sunlite for BitchX.
#
#    Sunlite for BitchX is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    Foobar is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Sunlite for BitchX; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
################################################################################
#
# These are the real utilities from the script (aliases for comfortable 
# using and new functionalities for BitchX).
#
# First of all, a ban script which auto-ops if we aren't operators on 
# channel before banning, deops target user before banning, 
# bans nick and mask + ip, and kicks with message. After, we deop ourselves 
# again if we are not channel oprator :) This ban script has been 
# designed from an original idea of core & kanueda. Their code
# is pasted below :)
#
# Also, we have a ban menu for our script. It's binded to Alt+b, very funny! :) 
#
alias tban {
  @ pringao = [$0]
  @ mensaje = [$1-]
  if ( [$Sonido] == 1 ) { exec bplay ~/.BitchX/sunlite/sonidos/kick.wav 2> /dev/null }
  if ( [$pringao] != "" ) {
    userhost $pringao -cmd {
      @ ident = [$3]
      @ ip    = [$4] }
    if (![$P] && [$C]) {
      opme
      on -mode 'CHaN $C +o $N' {
        mode $C -o+bb $pringao $pringao*!*@* *!$ident@$ip
        kick $C $pringao $mensaje
	deop $C $N } 
    } {
      mode $C -o+bb $pringao $pringao*!*@* *!$ident@$ip
      kick $C $pringao $mensaje }
 } {
   mode $C -o+bb $pringao $pringao*!*@* *!$ident@$ip
   kick $C $pringao $mensaje } }

alias tban_input {
  @ Ban = ([$Ban] +1)
  exec echo "@ Ban = $Ban" > ~/.BitchX/sunlite/.bans
  input "$cparse("%RNick to ban: ")" {
    if ( [$0] != "" ) {
      if (rmatch($0 $onchannel($C)) >= 1) {
        @ pringao = [$0]
        input "$cparse("%RKick message: ")" {
          if ( [$0] != "" ) {
            tban $pringao $0- <nº $Ban>
          } {
            tban $pringao Go home... <nº $Ban> } } } } } }
if ( [$hotkey] == [ctrl] ) {
  bind ^b parse_command tban_input
} elsif ( [$hotkey] == [alt] ) {
  bind META1-b parse_command tban_input }

# This is the original ban script by core & kanueda.
#
## Función intermedia, *NO Invocar*
##
#alias alaputakalle {
#  mode $C +bbb $0*!*@* *!$1@* *!*@$2
#  kick $C $0 $3-
#  ignore $0 all
#}
#
## Utilidad para OPs - /arpeo nick razón
## Nos da OP (si no lo tenemos ya), kickea, banea (nick + ident + ip)
## e ignora a cualquier brasas que se esté raiando.. xD
## Despues nos vuelve a quitar el OP.. (umm.. manias de core.. xD)
##
#alias arpeo {
# @ kapullo_nick = [$0]
# @ kick_msg     = [$1-]
#
# userhost $kapullo_nick -cmd {
#   @ kapullo_ident = [$3]
#   @ kapullo_ip    = [$4]
# }
#
# if (![$P] && [$C]) {
#  opme
#  on -mode 'CHaN $C +o $N' {
#   alaputakalle $kapullo_nick $kapullo_ident $kapullo_ip $kick_msg
#   deop $C $N
#   on -mode - 'CHaN $C +o $N'
#  }
# } {
#  alaputakalle $kapullo_nick $kapullo_ident $kapullo_ip $kick_msg
# }
#}

# An abreviated and comfortable way to change our nick without adding password
# in arguments.
#
alias nick {
#  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1 ) {
#    identifica $0 
#  } {
    identifica $0 } 
#}

# These are several aliases for major comfort to negotiate with bots. 
# This is an original idea from core & kanueda too. I've modified
# the code a bit for multiserver bots support.
#
alias infoN {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m NiCK info $0
  } {
    m NickServ info $0 } }

alias infoCh {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m CHaN info $0
  } {
    m ChanServ info $0 } }

alias memoS {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m MeMO send $0 $1-
  } {
    m MemoServ send $0 $1- } }

alias memoR {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m MeMO read $0
  } {
    m MemoServ read $0 } }

alias memoD {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m MeMO del $0
  } {
    m MemoServ del $0 } }

alias memoL {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m MeMO list
  } {
    m MemoServ list } }

# These are added by me ;)
#
alias addlevel {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m CHaN access $C add $0 $1
  } {
    m ChanServ access $C add $0 $1 } }

alias dellevel {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m CHaN access $C del $0
  } {
    m ChanServ access $C del $0 } }

alias founder {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m CHaN identify $C $0-
  } {
    m ChanServ identify $C $0- } }

alias nickreg {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m NiCK register $0
  } {
    m NickServ register $0 } }

# We define an autojoin alias to access our favourite channels. 
#
alias autojoin {
    @ Joined = 1
    sleep 3 
    for ( @ i = 1, i < numwords($Canales_Aj), @ i++) { j $word($i $Canales_Aj) } 
    usleep .5
    clear
    j $word(0 $Canales_Aj) }
if ( [$hotkey] == [ctrl] ) {
  bind ^a parse_command autojoin
} elsif ( [$hotkey] == [alt] ) {
  bind META1-a parse_command autojoin }

# This is another add-on for BitchX. It cleans screen and shows topic & users
# (Hot-key -> Alt + l).
#
alias clean {
  clear
  if ( [$C] ) {
    topic $C
    names $C } }
if ( [$hotkey] == [ctrl] ) {
  bind ^l parse_command clean 
} elsif ( [$hotkey] == [alt] ) {
  bind META1-l parse_command clean }

# We marked as away and we active away notification on nick event
# ( through notices )
#
alias away {
  if ( [$Away] != 1 ) {
    if ( [$0] != "" ) {
      @ Away_msg = [$0-]
    } {
      @ Away_msg = [I wasn't here...] }
    @ Away = 1 
    //away -all $Away_msg   
  } {
    //away 
    @ Away = 0 } }

# Here we have a good utility such as a calculator ;)
#
alias calculator {
  input "$cparse("%REnter operation: ")" {
    if ( [$0] != "" ) {
      exec echo "The result is"
      exec echo "scale=3\;$0" | bc } } }

# Fast way to get channel operator status on channel if we have
# registry (Hot-key -> Alt + o).
#
alias opme {
  if ( mid(0 1 $winnam($winnum())) == [#] ) {
    if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
      m CHaN op $C $N 
    } {
      m ChanServ op $C $N } } }
if ( [$hotkey] == [ctrl] ) {
  bind ^o parse_command opme
} elsif ( [$hotkey] == [alt] ) {
  bind META1-o parse_command opme }
  
# We deop ourselves on channel we are (Hot-key -> Alt +d).
#
alias deopme {
  if ( mid(0 1 $winnam($winnum())) == [#] ) {
    deop $C $N } }
if ( [$hotkey] == [ctrl] ) {
  bind ^d parse_command deopme
} elsif ( [$hotkey] == [alt] ) {
  bind META1-d parse_command deopme }
  
# We get channel voice status on channel we are and we deop if we 
# have channel operator status (Hot-key -> Alt + v).
#
alias voiceme {
  if ( mid(0 1 $winnam($winnum())) == [#] ) {
    voice $N } }
if ( [$hotkey] == [ctrl] ) {
  bind ^v parse_command voiceme
} elsif ( [$hotkey] == [alt] ) {
  bind META1-v parse_command voiceme }
    
# We devoice ourselves on channel we are.
#
alias devoiceme {
  if ( mid(0 1 $winnam($winnum())) == [#] ) {
    devoice $N } }

# We change to +R mode on channel we are (it's useful on flood joins 
# & parts attack).
#
alias moderre {
  if ( mid(0 1 $winnam($winnum())) == [#] ) {
    mode $C +R } }
if ( [$hotkey] == [ctrl] ) {
  bind ^r parse_command moderre
} elsif ( [$hotkey] == [alt] ) {
  bind META1-r parse_command moderre }

# We left channel and delete window we are using on it.
#
alias part {
  if ( ( winnum() == 1 ) || ( winnum() == 2 ) ) {
    window goto $Principal }
  if ( [$0] != "" ) {
    //part $C $0
  } {
    //part $C $Msg_quit }
  if ( ( winnum() == 11 ) || ( ( winnum() == 12 ) && ( [$Partir] == 1 ) ) || ( winnum() == 1 ) ) { 
    window name Cierrame log off
    clear 
  } {
    window kill }
  if ( [$Sonido] == 1 ) { exec bplay ~/.BitchX/sunlite/sonidos/cierraw.wav 2> /dev/null }
  if ( [$partir] == 1 ) {
    window hide_others
    usleep .5
    window swap $Pos3 
    usleep .5
    window show $Pos2
    window show $Pos1
    recolocar } }
alias p part

# We left and join channel (it's dirty :-/)
# (Hot-Key -> Alt + j).
alias rejoin {
  if ( ( winnum() == 1 ) || ( winnum() == 2 ) ) {
    window goto $Principal } 
  @ Canal = [$C]
  //part $C }
if ( [$hotkey] == [alt] ) {
  bind META1-j parse_command rejoin
} elsif ( [$hotkey] == [ctrl] ) {
  bind ^g parse_command rejoin }

on ^timer "%:**" {
  @ Flood = 0
  if ( [$Canal] != "" ) {
    window swap $Canal
    //join $Canal
    @ Canal = "" } }

# We save the content on the screen to a binary file. It's necessary
# to use framebuffer and have read permission on device /dev/fb0
# (Hot-Key -> Alt + s). For looking at the snapshot `bzip2 -d 
# BitchX.jpg.bz2; cp BitchX.jpg /dev/fb0; bzip2 BitchX.jpg`
#
alias snapshot {
  @ snap = ([$snap] +1)
  exec cp /dev/fb0 BitchX$snap\.fb
  usleep .5
  exec bzip2 BitchX$snap\.fb }
if ( [$hotkey] == [ctrl] ) {
  bind ^s parse_command snapshot
} elsif ( [$hotkey] == [alt] ) {
  bind META1-s parse_command snapshot }
    
# We create a new window.
# WNS -> It creates a new window in a new server
# WNC -> It creates a new window with a new channel on current server
# Query -> It creates a new window to query on current server
# Querys -> It creates a new window to query on new server
#
alias WNS { 
  if ( ( ( winnum() == 1 ) || ( winnum() == 2 ) ) && ( [$partir] == 1 ) ) {
    window goto $Principal }
  window new server $0 hide swap last name Cierrame double on
  if ( [$partir] == 1 ) recolocar }
alias joins wns
alias server wns

alias WNC {
  if ( ( ( winnum() == 1 ) || ( winnum() == 2 ) ) && ( [$partir] == 1 ) ) {
    window goto $Principal }
  if ( mid(0 1 $0) == [#] ) {
    @ knal = [$0]
  } {
    @ knal = [#$0] }
  if ( winnum($knal) != [-1] ) {
      window swap $knal
  } elsif ( winnam($winnum()) == [Cierrame] ) {
    clear
    //join $knal
    window name $knal logfile ~/.BitchX/sunlite/logs/\#$mid(1 40 $knal)\.$servername($winserv()).log log on
  } {
    window new hide swap last name $knal channel $knal double on logfile ~/.BitchX/sunlite/logs/\#$mid(1 40 $knal)\.$servername($winserv()).log log on 
    if ( [$partir] == 1 ) recolocar } } 
alias join wnc
alias j wnc

alias query {
  @ lineas = 0
  if ( ( ( winnum() == 1 ) || ( winnum() == 2 ) ) && ( [$partir] == 1 ) ) {
    window goto $Principal }
  if ( ( [$0] == [hide] ) && ( winnum($1) == [-1] ) ) {
    @ knal = [$C]
    if ( winnam($winnum()) != [Cierrame] ) { 
      window new query $1 name $1 hide 
    } { 
      //query $1
      clear
      window name $1 }
    if ( [$partir] == 1 ) recolocar 
    @ $1 = 1
    if ( fexist(~/.BitchX/sunlite/logs/$1.log) != -1 ) {
      @ fileid = [$open(~/.BitchX/sunlite/logs/$1.log R)]
      while ( ! ( eof($fileid) == 1 ) ) {
        @ temp = [$read($fileid)]
        @ lineas = ([$lineas] + 1]) }
      if ( close($fileid) == -1 ) xecho -win status $cparse("$Blanco\ERROR !!!$Verde on closing file")
      @ fileid = [$open(~/.BitchX/sunlite/logs/$1.log R)]
      while ( ! ( eof($fileid) == 1 ) ) {
        @ lineas = ([$lineas] - 1])
        @ temp = [$read($fileid)]
        if ( [$lineas] <= 30 ) xecho -win $winnum($1) $cparse("$temp") 
	if ( [$lineas] == 30 ) {
	  echo
	  exec echo "Last opened session `cat /home/trunks/.BitchX/sunlite/logs/trunks.log | grep \"IRC log started\" | tail -n 1 | gawk '{ print $4 \" \" $6 \" \" $5 \" \" $8 \" at \" $7}'`" } }
      if ( close($fileid) == -1 ) xecho -win status $cparse("$Blanco\ERRROR !!!$Verde on closing file") }
    window logfile ~/.BitchX/sunlite/logs/$1.log log on
  } elsif ( ( [$0] != "" ) && ( [$0] != [hide] ) && ( winnum($0) == [-1] ) ) {
    @ knal = [$0]
    if ( winnam($winnum()) != [Cierrame] ) {
      window new query $0 name $0 hide swap last 
    } {
      //query $0 
      clear
      window name $0 }
    if ( [$partir] == 1 ) recolocar
    if ( [$Sonido] == 1 ) { exec bplay ~/.BitchX/sunlite/sonidos/abrew.wav 2> /dev/null }
    @ $0 = 1
    if ( fexist(~/.BitchX/sunlite/logs/$0.log) != -1 ) {
      @ fileid = [$open(~/.BitchX/sunlite/logs/$0.log R)]
      while ( ! ( eof($fileid) == 1 ) ) {
        @ temp = [$read($fileid)]
        @ lineas = ([$lineas] + 1]) }
      if ( close($fileid) == -1 ) xecho -win status $cparse("$Blanco\ERROR !!!$Verde on closing file")
      @ fileid = [$open(~/.BitchX/sunlite/logs/$0.log R)]
      while ( ! ( eof($fileid) == 1 ) ) {
        @ lineas = ([$lineas] - 1])
        @ temp = [$read($fileid)]
        if ( [$lineas] <= 30 ) xecho -win $winnum($0) $cparse("$temp") 
	if ( [$lineas] == 30 ) {
	  echo
	  exec echo "Last opened window `cat /home/trunks/.BitchX/sunlite/logs/trunks.log | grep \"IRC log started\" | tail -n 1 | gawk '{ print $4 \" \" $6 \" \" $5 \" \" $8 \" at \" $7}'`" } }
      if ( close($fileid) == -1 ) excho -win status $cparse("$Blanco\ERROR !!! on closing file") }
    window logfile ~/.BitchX/sunlite/logs/$0.log log on
  } elsif ( ( winnum($0) != [-1] ) && ( [$0] != [] ) ) { 
    window swap $0 
  } {
    if ( mid(1 1 $winnam($winnum())) == [#] ) {
      part
    } {
      //query
      @ $winnam($winnum()) = 0
      if ( ( winnum() == 11 ) || ( ( winnum() == 12 ) && ( [$Partir] == 1 ) ) || ( winnum() == 1 ) ) {
        window name Cierrame log off
        clear 
      } {
        window kill }
      if ( [$Sonido] == 1 ) { exec bplay ~/.BitchX/sunlite/sonidos/cierraw.wav 2> /dev/null }
      if ( [$partir] == 1 ) {
        window hide_others
        usleep .5
        window swap $Pos3 
        usleep .5
        window show $Pos2
        window show $Pos1
        recolocar } } } }
alias q query
if ( [$hotkey] == [ctrl] ) {
  bind ^z parse_command query
} elsif ( [$hotkey] == [alt] ) {
  bind META1-z parse_command query }
    
alias querys {
  if ( ( ( winnum() == 1 ) || ( winnum() == 2 ) ) && ( [$partir] == 1 ) ) {
    window goto $Principal }
  @ knal = [$0]
  window new server $0 hide swap last name $1 query $1 logfile ~/.BitchX/sunlite/logs/$1.log log on
  if ( [$partir] == 1 ) recolocar
  if ( [$Sonido] == 1 ) { exec bplay ~/.BitchX/sunlite/sonidos/abrew.wav 2> /dev/null } }

# Well, this bind function is used to go to last window ;)
if ( [$hotkey] == [ctrl] ) {
  bind ^u SWAP_LAST_WINDOW
} elsif ( [$hotkey] == [alt] ) {
  bind META1-u SWAP_LAST_WINDOW }
    
# We clean bans we have on current channel if they exist.
#
alias fban { 
  if (![$P] && [$C]) {
    opme
    on -mode 'CHaN $C +o $N' {
      mode $C -bbbb $N!*@* *!$my_ident@* *!*@$my_ip *!$my_ident@$my_ip } 
  } {
    mode $C -bbbb $N!*@* *!$my_ident@* *!*@$my_ip *!$my_ident@$my_ip } }

# Conference mode :)
#
alias Conference {
  if ( [$Conferencia] == 1 ) {
    @ Conferencia = 0
    @ Conf_canal = ""
  } {
    @ Conferencia = 1
    @ Conf_canal = [$C] } }
if ( [$hotkey] == [ctrl] ) {
  bind ^c parse_command Conference
} elsif ( [$hotkey] == [alt] ) {
  bind META1-c parse_command Conference }
    
# An utility to send sms from our BitchX command line 
#
alias sms {
  if (( [$0] == "" ) || ( [$1] == "" )) {
    xecho -win status $cparse("Usage: /sms gateway nombre texto")
    xecho -win status $cparse("Esms gateways supported: navegalia & movistar")
  } {
    exec echo $2- | esms -s $0 $1 } }

# With this function you'll get fast accessing to the window in where your 
# nick has been said 
#
alias cambio_ventana {
  if ( ( ( winnum() == 1 ) || ( winnum() == 2 ) ) && ( [$Partir] == 1 ) ) {
    window goto $Principal }
  if ( [$Nick_en_canal] != "" && [$Nick_en_canal] != [$C] ) {
      window swap $Nick_en_canal
      @ Nick_en_canal = "" } }
if ( [$hotkey] == [ctrl] ) {
  bind ^x parse_command cambio_ventana
} elsif ( [$hotkey] == [alt] ) {
  bind META1-x parse_command cambio_ventana }
    
# With the instruction /shell <password> we hold BX on backgorund while
# we do any operation we need on shell. Also it can be used when we aren't behind
# the keyboard and want nobody read what we are talking about ;) For coming back 
# BX we should type 'scr-bx -p' on the shell and then we have to type the password
# defined previously. 
#
alias shell {
  if ( [$0] != [] ) detach $0 }

# Well, for ascii-art geeks, cause this an irc script, I've included some aliases to
# do ascii shapes. But remeber to install cowsay and figlet packets.
#
alias cowsay {
  switch ( $0 ) {
    ( regular ) { exec -o cowsay $1- }
    ( risa ) { exec -o cowsay -y $1- }
    ( tux ) { exec -o cowsay -f tux $1- }
    ( burla ) { exec -o cowsay -d $1- }
    ( susto ) { exec -o cowsay -w $1- }
    ( * ) {
      xecho -win status Usage: /cowsay {regular|burla|tux|susto} text } } }

alias figlet {
  switch ( $0 ) {
    ( regular ) { exec -o figlet $1- }
    ( mini ) { exec -o figlet -f mini $1- }
    ( banner ) { exec -o figlet -f banner $1- }
    ( italic ) { exec -o figlet -f slant $1- }
    ( script ) { exec -o figlet -f script $1- }
    ( block ) { exec -o figlet -f block $1- }
    ( bubble ) { exec -o figlet -f bubble $1- }
    ( digital ) { exec -o figlet -f digital $1- }
    ( * ) {
      xecho -win status Usage: /figlet {regular|banner|mini|italic|script|block|bubble} text } } }
	  
# We use mpg123 like our mp3 player on BitchX ;) The commands to play songs on this player are: 
#
#   /mp3 list 		-List the content of the mp3 directory we have defined in Mp3dir var.
#   /mp3 play RefNum|file	-Play the sound file.
#   /mp3 stop		-Stop playing proccess.
#   /mp3 dir ruta	-Define a new path to select our sound files.
#
alias mp3 {
  switch ( $0 ) {
    ( list ) {
      exec ls -1 -F $Mp3dir | gawk '{print "[" , NR, "]", $0}'
      xecho -win status $cparse("$Blanco\For playing: $AzulF\/mp3 play Refnum|Nombre_archivo") }
    ( play ) {
      @ RefNum = [$1]
      if ( [$1] == "" )  {
        xecho -win status $cparse("$Blanco\Select a title to play, ¿ok? :)")
      } elsif ( isdigit($1) ) {
        exec mpg123 "$Mp3dir/`ls -1 $Mp3dir/ | head -n $RefNum | tail -n 1`" 2> /dev/null
        if ( [$Notif_mp3] == 1 ) {
	    exec -o  echo "Mmm... I'm checking out `ls -1 $Mp3dir/ | head -n $RefNum | tail -n 1`" }
      } elsif ( [$1] == [\*] ) { 
        exec mpg123 $Mp3dir/\* 2> /dev/null
      } elsif ( [$1] == [\*/\*] ) {
        exec mpg123 $Mp3dir/\*/\* 2> /dev/null
      } {
        exec mpg123 "$Mp3dir/$RefNum" 2> /dev/null
        if ( [$Notif_mp3] == 1 ) {
	  exec -o  echo "Mmm... I'm checking out `ls -1 $Mp3dir/ | grep $RefNum`" } } }
    ( stop ) {
      exec killall mpg123 2> /dev/null }
    ( dir ) {
      if ( [$1-] != "" ) {
        @ Mp3dir = [$1-]
      } {
        xecho -win status $cparse("$Blanco\Mp3's dir is [$Mp3dir]. If you want to change it, type: $AzulF\/mp3 dir path") } }
    ( * ) {
      xecho -win status $cparse("$Blanco\Usage: $AzulF\/mp3 {list|play|stop|dir}") } } }

# We use cdcd like our cd player on BitchX ;) The comands to play songs on this player are:
#
#   /cd list           -List the Cd content.
#   /cd play RefNum    -Play the track RefNum.
#   /cd stop           -Stop playing proccess.
#   /cd refresh        -Refresh play list.
#
alias cd {
  switch ( $0 ) {
    ( list ) { 
      exec cdcd tracks }
    ( play ) {
      @ RefNum = [$1]
      if ( isdigit($1) ) {
        exec cdcd play $RefNum
        @ RefNum = ([$RefNum] + 6)
        if ( [$Notif_mp3] == 1 ) {
          exec -o echo "Mmm... I'm checking out `cdcd tracks | grep \"Album artist\" | cut -c 17-`: `cdcd tracks | head -n $RefNum | tail -n 1 | cut -c 21-`" }       
      } elsif ( [$RefNum] == [\*] ) {
        exec cdcd rndplay 
      } {
        xecho -win status $cparse("$Blanco\Usage: $Azulf\/cd {list|play RefNum|stop|refresh}") } }
    ( stop ) { 
      exec cdcd stop }
    ( refresh ) { 
      exec cdcd refresh }
    ( * ) { 
      xecho -win status $cparse("$Blanco\Usage: $Azulf\/cd {list|play|stop|refresh}") } } }

# We defined a new version for this script with a new message added to default BitchX version
#
alias version {
  //version
  echo $cparse("$RojoF-$Blanco:$RojoF-") $J }

# Colour themes in BitchX
#
alias color {
  if ( ( [$0] == [si] ) || ( [$0] == [sí] ) || ( [$VerdeF] == [] ) ) {
    if ( [$theme] == [bass] ) {
      @ VerdeF = [%g]
      @ Blanco = [%c]
      @ Amarillo = [%B]
      @ Magenta = [%Y]
      @ Violeta = [%c]
      @ Verde = [%g]
      @ RojoF = [%r]
      @ Rojo = [%r]
      @ AzulF = [%B]
      @ Gris = [%w]
      @ Naranja = [%b]
      @ CyanF = [%C]
      @ Cyan = [%c]
      set mircs on
    } {
      @ VerdeF = [%G]
      @ Verde = [%g]
      @ RojoF = [%R]
      @ Rojo = [%r]
      @ AzulF = [%B]
      @ Blanco = [%W]
      @ Gris = [%w]
      @ Amarillo = [%Y]
      @ Naranja = [%y]
      @ Magenta = [%M]
      @ Violeta = [%m]
      @ CyanF = [%C]
      @ Cyan = [%c]
      set mircs on }
  } {
    @ VerdeF = []
    @ Verde = []
    @ RojoF = []
    @ Rojo = []
    @ AzulF = []
    @ Blanco = []
    @ Gris = []
    @ Amarillo = []
    @ Naranja = []
    @ Magenta = []
    @ Violeta = []
    @ CyanF = []
    @ Cyan = [] 
    set mircs off } }

alias sonido {
  if ( ( [$0] == [si] ) || ( [$0] == [sí]) || ( [$Sonido] == 0 ) || ( [$0] == [on] ) ) {
    set beep on
    @ Sonido = 1
  } {
    set beep off
    @ Sonido = 0 } }

# This code has been generated by L00PB4cK and modified by {Trunks}
#
# Nick identification from a file with encrypted passwords
#
alias identifica { 
  if ( [$0] != "" ) {
    @ NNick = [$0]
  } {
    @ NNick = [$N] }
  if ($fexist(~/.BitchX/sunlite/passwd.bx) != -1) {
    @ fileid = [$open(~/.BitchX/sunlite/passwd.bx R)]
    @ findid = 0
    while ( ( eof($fileid) == 0) && ( $findid != 1) ) {
      @ temp = [$read($fileid)]
      @ temp1 = [$decode($temp)]
      @ nickid = [$midw(0 1 $temp1)]
      @ passid = [$midw(1 1 $temp1)]
      @ net = [$midw(2 1 $temp1)]
      if (( [$NNick] == [$nickid] ) && ( [$findid] == 0 )) {
        if ( ( match(hispano $reverse($mid(4 7 $reverse($net)))) >= 1) && ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1 )) {
          msg nick@deep.space identify $passid
          quote nick $NNick:$passid
          @ findid = 1
        } elsif ( ( match(openprojects $reverse($mid(4 12 $reverse($net)))) >= 1 ) && ( match(openprojects $reverse($mid(4 12 $reverse($servername($winserv()))))) >= 1 )) {
          //nick $NNick
          msg nickserv identify $passid
          @ findid = 1
        } elsif ( ( match(dal $reverse($mid(4 3 $reverse($net)))) >= 1 ) && ( match(dal $reverse($mid(4 3 $reverse($servername($winserv()))))) >= 1 )) {
          //nick $NNick
          msg nickserv@services.dal.net identify $passid
          @ findid = 1 } } }
    if ( close($fileid) == -1) {
      xecho -win status $cparse("$RojoF\ERROR $Blanco!!!$Verde on closing database") }
    if ([$findid] == 0) {
      input "$cparse("%REnter the password for $NNick: ")" {
        if ( [$0] != "" ) {
          @ passid = [$0]
        @ fileid = [$open(~/.BitchX/sunlite/passwd.bx R)]
        while ( ( eof($fileid) == 0) && ( $findid != 1 ) ) {
          @ temp = [$read($fileid)]
          @ temp1 = [$decode($temp)]
          @ nickid = [$midw(0 1 $temp1)]
          @ net = [$midw(2 1 $temp1)]
          if ([$NNick] == [$nickid]) {
            if ( ( servername($winserv()) == match($net $reverse($mid(4 7 $reverse($servername($winserv()))))) || servername($winserv()) == match($net $reverse($mid(4 3 $reverse($servername($winserv()))))) || servername($winserv()) == match($net $reverse($mid(4 12 $reverse($servername($winserv()))))))) {
              @ find = 1 } } }
        if ( close($fileid) == 1) {
          xecho -win status $cparse("$Verde\Error on closing file") }
        if ( [$find] == 1 ) {
           xecho -win status $cparse("$Verde\The nick $1 is already in database on the net $3")
        } {
          @ fileid = [$open(~/.BitchX/sunlite/passwd.bx W)]
          @ temp2 = [$NNick] ## [ ] ## [$passid] ## [ ] ## [$servername($winserv())]
          @ encoded = [$encode($temp2)]
          if ( write($fileid $encoded) == -1) {
            xecho -win status $cparse("$Verde\Writing to file")
          } {
            xecho -win status $cparse("$Verde\Data has been writed success") 
            identifica $NNick }
          if ( close($fileid) == 1) {
            xecho -win status $cparse("$Verde\Error on closing file") } } } } } } }

# This is a new command to mark as away and change our nick.
# Original idea by |Poldark| I've modified his original development to
# use aliases which are already designed.
alias awayon {
  nick $nick_awayOn
  deopme
  away $0- }

alias awayoff {
  nick $nick_awayOff
  if ( ! [$P] && [$C] ) {
    on -nickname '$N' opme }
  away
  if ( [$0] != "" ) {
    me $0- } }

# Custom output message from the script
#
alias quit {
  if ( [$0] == "" ) {
    //quit $Msg_quit
  } {
    //quit $0- } }

# Use this alias to send a string to a Xterm ;) It's very useful when we 
# are executing BitchX on a tty and we need to send an url to our favourite X browser
# ;)
#
# - Poldark, thanks for your help ;) -
#
alias termX {
  exec echo '$0-' > /dev/`ps u | grep pts | head -n1 | gawk '{print $7}'` }

# This is a translator english/spanish spanish/english. It's useful when we are talking with
# spanish guys and we don't remember the exact word we want to type ;)
#
# Usage: /translate [inglés|ingles|english|español|spanish] word ( Default it
# translates from english to spanish )
#
alias traducir {
  if ( [$0] == "" ) {
    xecho -win status $cparse("$Blanco\Usage: $AzulF/translate [ingles|inglés|english|español|spanish] word \( As default it will translate the word to spanish from english \)")
  } elsif ( ( [$0] == [inglés] ) || ( [$0] == [ingles] ) || ( [$0] == [english] ) ) { 
    exec i2e.sh -re $1
  } elsif ( ( [$0] == [español] ) || ( [$0] == [spanish] ) ) {
    exec i2e.sh -e $1
  } {
    exec i2e.sh -e $0 } }
alias translate traducir

# You can use this translate to fix all your windows.  
#
alias recolocar {
  switch ( $Pos1 ) {
    ( 11 ) {
      switch ( $Pos2 ) {
        ( 12 ) {
          window goto 1
          window size 5
          window goto 2
          window size 7
          window goto 3 }
        ( 1 ) {
          window goto 3
          window size 7
          window goto 1
          window size 5
          window goto 2 } } }
    ( 12 ) {
      switch ( $Pos2 ) {
        ( 11 ) {
          window goto 1
          window size 7
          window goto 2
          window size 5
          window goto 3 }
        ( 1 ) {
          window goto 3
          window size 5
          window goto 1
          window size 7
          window goto 2 } } }
    ( 1 ) {
      switch ( $Pos2 ) {
        ( 11 ) {
          window goto 2
          window size 5
          window goto 3
          window size 7
          window goto 1 }
        ( 12 ) {
          window goto 2
          window size 7
          window goto 3
          window size 5
          window goto 1 } } } } }

# These are some hot-keys: To swap over windows if we use split windows,
# and two more for swapping to left or right window 
#
if ( [$hotkey] == [alt] ) {
  bind META1-q NEXT_WINDOW
  bind META1-w SWAP_PREVIOUS_WINDOW
  bind META1-e SWAP_NEXT_WINDOW
  bind META1-n notify
} elsif ( [$hotkey] == [ctrl] ) {
  bind ^q NEXT_WINDOW
  bind ^w SWAP_PREVIOUS_WINDOW
  bind ^e SWAP_NEXT_WINDOW 
  bind ^n notify }

bind META32-~ beginning_of_line
bind META33-~ end_of_line
bind META1-, beginning_of_line
bind META1-. end_of_line

# Copyright © 2002 Javier Carranza
