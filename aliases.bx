#
#    This file is part of Sunlite for BitchX.
#
#    Sunlite for BitchX is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    Foobar is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with Sunlite for BitchX; if not, write to the Free Software
#    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
################################################################################
#
# Finalment les utilitats reals de l'script (alieases per a una major
# comoditat d'ús y noves funcionalitats pel BitchX).
#
# En primer lloc un ban script que auto-opeja si no som operadors del 
# canal abans de banejar, deopeja a l'usuari en qüestió abans de banejarlo, 
# baneja a nick i mascara + ip, i kickeja amb missatge. Posteriorment ens 
# deopeja novament si no teniem op anteriorment :) Aquest ban script ha 
# estat disenyat a partir d'una idea original de core & kanueda de la que
# donem el codi a continuació del nostre comentat :)
#
# Apart tenim un "menú" de baneig pel nostre ban script bindejat a 
# la combinación de teclas Alt-b molt pijito :) No us queixareu ! xD
#
alias tban {
  @ pringao = [$0]
  @ mensaje = [$1-]
  if ( [$Sonido] == 1 ) { exec bplay ~/.BitchX/sunlite/sonidos/kick.wav 2> /dev/null }
  if ( [$pringao] != "" ) {
    userhost $pringao -cmd {
      @ ident = [$3]
      @ ip    = [$4] }
    if (![$P] && [$C]) {
      opme
      on -mode 'CHaN $C +o $N' {
        mode $C -o+bb $pringao $pringao*!*@* *!$ident@$ip
        kick $C $pringao $mensaje
	deop $C $N } 
    } {
      mode $C -o+bb $pringao $pringao*!*@* *!$ident@$ip
      kick $C $pringao $mensaje }
 } {
   mode $C -o+bb $pringao $pringao*!*@* *!$ident@$ip
   kick $C $pringao $mensaje } }

alias tban_input {
  @ Ban = ([$Ban] +1)
  exec echo "@ Ban = $Ban" > ~/.BitchX/sunlite/.bans
  input "$cparse("%RNick a banear: ")" {
    if ( [$0] != "" ) {
      if (rmatch($0 $onchannel($C)) >= 1) {
        @ pringao = [$0]
        input "$cparse("%RMensaje de kickeo: ")" {
          if ( [$0] != "" ) {
            tban $pringao $0- <nº $Ban>
          } {
            tban $pringao A casita... <nº $Ban> } } } } } }
if ( [$hotkey] == [ctrl] ) {
  bind ^b parse_command tban_input
} elsif ( [$hotkey] == [alt] ) {
  bind META1-b parse_command tban_input }

# Aquest és el ban script original de core & kanueda.
#
## Función intermedia, *NO Invocar*
##
#alias alaputakalle {
#  mode $C +bbb $0*!*@* *!$1@* *!*@$2
#  kick $C $0 $3-
#  ignore $0 all
#}
#
## Utilidad para OPs - /arpeo nick razón
## Nos da OP (si no lo tenemos ya), kickea, banea (nick + ident + ip)
## e ignora a cualquier brasas que se esté raiando.. xD
## Despues nos vuelve a quitar el OP.. (umm.. manias de core.. xD)
##
#alias arpeo {
# @ kapullo_nick = [$0]
# @ kick_msg     = [$1-]
#
# userhost $kapullo_nick -cmd {
#   @ kapullo_ident = [$3]
#   @ kapullo_ip    = [$4]
# }
#
# if (![$P] && [$C]) {
#  opme
#  on -mode 'CHaN $C +o $N' {
#   alaputakalle $kapullo_nick $kapullo_ident $kapullo_ip $kick_msg
#   deop $C $N
#   on -mode - 'CHaN $C +o $N'
#  }
# } {
#  alaputakalle $kapullo_nick $kapullo_ident $kapullo_ip $kick_msg
# }
#}

# Una forma abreviada i cómoda de canviar-se el nick sense haber d'afegir
# el password :)
#
alias nick {
#  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1 ) {
#    identifica $0 
#  } {
    identifica $0 } 
#}

# Aquests són un parell d'aliases per major comoditat a l'hora
# d'interactuar amb els bots de L'IRC-Hispano. També és idea original de
# core & kanueda. He retocat una mica el códi pel suport de bots
# multiservidor
#
alias infoN {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m NiCK info $0
  } {
    m NickServ info $0 } }

alias infoCh {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m CHaN info $0
  } {
    m ChanServ info $0 } }

alias memoS {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m MeMO send $0 $1-
  } {
    m MemoServ send $0 $1- } }

alias memoR {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m MeMO read $0
  } {
    m MemoServ read $0 } }

alias memoD {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m MeMO del $0
  } {
    m MemoServ del $0 } }

alias memoL {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m MeMO list
  } {
    m MemoServ list } }

# I aquests afegits per mi ;)
#
alias addlevel {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m CHaN access $C add $0 $1
  } {
    m ChanServ access $C add $0 $1 } }

alias dellevel {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m CHaN access $C del $0
  } {
    m ChanServ access $C del $0 } }

alias founder {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m CHaN identify $C $0-
  } {
    m ChanServ identify $C $0- } }

alias nickreg {
  if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
    m NiCK register $0
  } {
    m NickServ register $0 } }

# Definim un alias a autojoin per accedir als canals que més ens
# agradan de la xarxa
#
alias autojoin {
    @ Joined = 1
    sleep 3 
    for ( @ i = 1, i < numwords($Canales_Aj), @ i++) { j $word($i $Canales_Aj) } 
    usleep .5
    clear
    j $word(0 $Canales_Aj) }
if ( [$hotkey] == [ctrl] ) {
  bind ^a parse_command autojoin
} elsif ( [$hotkey] == [alt] ) {
  bind META1-a parse_command autojoin }

# Aquest és un altre dels nostres afegits d'utilitat pel BitchX. Ens neteja
# la finestre y ens presenta el Topic del canal seguit dels usuaris hi que
# "viuen" xD (Hot-key -> Alt + l).
#
alias limpia {
  clear
  if ( [$C] ) {
    topic $C
    names $C } }
if ( [$hotkey] == [ctrl] ) {
  bind ^l parse_command limpia
} elsif ( [$hotkey] == [alt] ) {
  bind META1-l parse_command limpia }

# Ens marquem com a away i activem la notivicació per qui
# digui el nostre nick ( mitjançant notices )
#
alias away {
  if ( [$Away] != 1 ) {
    if ( [$0] != "" ) {
      @ Away_msg = [$0-]
    } {
      @ Away_msg = [No estic...] }
    @ Away = 1 
    //away -all $Away_msg   
  } {
    //away 
    @ Away = 0 } }

# Aquí tenim una bona utilitat que ens serveix de calculadora ;)
#
alias calculadora {
  input "$cparse("%RInserte operación: ")" {
    if ( [$0] != "" ) {
      exec echo "El resultat de la operació $0 és"
      exec echo "scale=3\;$0" | bc } } }

# Una manera ràpida d'aconsseguir arroba als canals als que
# estem registrats (Hot-key -> Alt + o).
#
alias opme {
  if ( mid(0 1 $winnam($winnum())) == [#] ) {
    if ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1) {
      m CHaN op $C $N 
    } {
      m ChanServ op $C $N } } }
if ( [$hotkey] == [ctrl] ) {
  bind ^o parse_command opme
} elsif ( [$hotkey] == [alt] ) {
  bind META1-o parse_command opme }
  
# Ens deopejem al canal al que ens trobem (Hot-key -> Alt +d).
#
alias deopme {
  if ( mid(0 1 $winnam($winnum())) == [#] ) {
    deop $C $N } }
if ( [$hotkey] == [ctrl] ) {
  bind ^d parse_command deopme
} elsif ( [$hotkey] == [alt] ) {
  bind META1-d parse_command deopme }
  
# Ens dona veu al canal y ens treiem la nostra arrobeta si som
# operadors del canal (Hot-key -> Alt +  v).
#
alias voiceme {
  if ( mid(0 1 $winnam($winnum())) == [#] ) {
    voice $N } }
if ( [$hotkey] == [ctrl] ) {
  bind ^v parse_command voiceme
} elsif ( [$hotkey] == [alt] ) {
  bind META1-v parse_command voiceme }
    
# Ens treiem la veu al canal al que ens trobem.
#
alias devoiceme {
  if ( mid(0 1 $winnam($winnum())) == [#] ) {
    devoice $N } }

# Posem el canal en Mode +R (per atacs per flood de joins & parts).
#
alias moderre {
  if ( mid(0 1 $winnam($winnum())) == [#] ) {
    mode $C +R } }
if ( [$hotkey] == [ctrl] ) {
  bind ^r parse_command moderre
} elsif ( [$hotkey] == [alt] ) {
  bind META1-r parse_command moderre }

# Sortim del canal actual i eliminem la finestra que estem utilitzant
# per a aquest canal
#
alias part {
  if ( ( winnum() == 1 ) || ( winnum() == 2 ) ) {
    window goto $Principal }
  if ( [$0] != "" ) {
    //part $C $0
  } {
    //part $C $Msg_quit }
  if ( ( winnum() == 11 ) || ( ( winnum() == 12 ) && ( [$Partir] == 1 ) ) || ( winnum() == 1 ) ) { 
    window name Cierrame log off
    clear 
  } {
    window kill }
  if ( [$Sonido] == 1 ) { exec bplay ~/.BitchX/sunlite/sonidos/cierraw.wav 2> /dev/null }
  if ( [$partir] == 1 ) {
    window hide_others
    usleep .5
    window swap $Pos3 
    usleep .5
    window show $Pos2
    window show $Pos1
    recolocar } }
alias p part

# Sortim i entrem al canal actual (quina cosa més "cutre" q he fet)
# (Hot-Key -> Alt + j).
alias rejoin {
  if ( ( winnum() == 1 ) || ( winnum() == 2 ) ) {
    window goto $Principal } 
  @ Canal = [$C]
  //part $C }
if ( [$hotkey] == [alt] ) {
  bind META1-j parse_command rejoin
} elsif ( [$hotkey] == [ctrl] ) {
  bind ^g parse_command rejoin }

on ^timer "%:**" {
  @ Flood = 0
  if ( [$Canal] != "" ) {
    window swap $Canal
    //join $Canal
    @ Canal = "" } }

# Copiem a un arxiu el contingut visualitzat per pantalla. Es requereix
# estar utilitzant framebuffer i tindre permis per llegir el dispositiu
# /dev/fb0 (Hot-Key -> Alt + s). Per veure la snapshot `bzip2 -d 
# BitchX.jpg.bz2; cp BitchX.jpg /dev/fb0; bzip2 BitchX.jpg`
#
alias snapshot {
  @ snap = ([$snap] +1)
  exec cp /dev/fb0 BitchX$snap\.fb
  usleep .5
  exec bzip2 BitchX$snap\.fb }
if ( [$hotkey] == [ctrl] ) {
  bind ^s parse_command snapshot
} elsif ( [$hotkey] == [alt] ) {
  bind META1-s parse_command snapshot }
    
# Creem una nova finestra.
# WNS -> Nova finestra pel canal del nostre servidor
# WNC -> Nova finestra pel canal de servidor actual
# Query -> Nova finestra per privat al servidor actual
# Querys -> Nova finestra per privat a un altre servidor
#
alias WNS { 
  if ( ( ( winnum() == 1 ) || ( winnum() == 2 ) ) && ( [$partir] == 1 ) ) {
    window goto $Principal }
  window new server $0 hide swap last name Cierrame double on
  if ( [$partir] == 1 ) recolocar }
alias joins wns
alias server wns

alias WNC {
  if ( ( ( winnum() == 1 ) || ( winnum() == 2 ) ) && ( [$partir] == 1 ) ) {
    window goto $Principal }
  if ( mid(1 1 $0) == [#] ) {
    @ knal = [$0]
  } {
    @ knal = [#$0] }
  if ( winnum($knal) != [-1] ) {
      window swap $knal
  } elsif ( winnam($winnum()) == [Cierrame] ) {
    clear
    //join $knal
    window name $knal logfile ~/.BitchX/sunlite/logs/\#$mid(1 40 $knal)\.$servername($winserv()).log log on
  } {
    window new hide swap last name $knal channel $knal double on logfile ~/.BitchX/sunlite/logs/\#$mid(1 40 $knal)\.$servername($winserv()).log log on 
    if ( [$partir] == 1 ) recolocar } } 
alias join wnc
alias j wnc

alias query {
  @ lineas = 0
  if ( ( ( winnum() == 1 ) || ( winnum() == 2 ) ) && ( [$partir] == 1 ) ) {
    window goto $Principal }
  if ( ( [$0] == [hide] ) && ( winnum($1) == [-1] ) ) {
    @ knal = [$C]
    if ( winnam($winnum()) != [Cierrame] ) { 
      window new query $1 name $1 hide 
    } { 
      //query $1
      clear
      window name $1 }
    if ( [$partir] == 1 ) recolocar 
    @ $1 = 1
    if ( fexist(~/.BitchX/sunlite/logs/$1.log) != -1 ) {
      @ fileid = [$open(~/.BitchX/sunlite/logs/$1.log R)]
      while ( ! ( eof($fileid) == 1 ) ) {
        @ temp = [$read($fileid)]
        @ lineas = ([$lineas] + 1]) }
      if ( close($fileid) == -1 ) xecho -win status $cparse("$Blanco¡¡¡ ERROR !!!$Verde cerrando fichero")
      @ fileid = [$open(~/.BitchX/sunlite/logs/$1.log R)]
      while ( ! ( eof($fileid) == 1 ) ) {
        @ lineas = ([$lineas] - 1])
        @ temp = [$read($fileid)]
        if ( [$lineas] <= 30 ) xecho -win $winnum($1) $cparse("$temp") 
	if ( [$lineas] == 30 ) {
	  echo
	  exec echo "Última sesió oberta `cat /home/trunks/.BitchX/sunlite/logs/trunks.log | grep \"IRC log started\" | tail -n 1 | gawk '{ print $4 \" \" $6 \" \" $5 \" \" $8 \" a las \" $7}'`" } }
      if ( close($fileid) == -1 ) xecho -win status $cparse("$Blanco¡¡¡ ERRROR !!!$Verde cerrando fichero") }
    window logfile ~/.BitchX/sunlite/logs/$1.log log on
  } elsif ( ( [$0] != "" ) && ( [$0] != [hide] ) && ( winnum($0) == [-1] ) ) {
    @ knal = [$0]
    if ( winnam($winnum()) != [Cierrame] ) {
      window new query $0 name $0 hide swap last 
    } {
      //query $0 
      clear
      window name $0 }
    if ( [$partir] == 1 ) recolocar
    if ( [$Sonido] == 1 ) { exec bplay ~/.BitchX/sunlite/sonidos/abrew.wav 2> /dev/null }
    @ $0 = 1
    if ( fexist(~/.BitchX/sunlite/logs/$0.log) != -1 ) {
      @ fileid = [$open(~/.BitchX/sunlite/logs/$0.log R)]
      while ( ! ( eof($fileid) == 1 ) ) {
        @ temp = [$read($fileid)]
        @ lineas = ([$lineas] + 1]) }
      if ( close($fileid) == -1 ) xecho -win status $cparse("$Blanco¡¡¡ ERROR !!!$Verde tancant arxiu")
      @ fileid = [$open(~/.BitchX/sunlite/logs/$0.log R)]
      while ( ! ( eof($fileid) == 1 ) ) {
        @ lineas = ([$lineas] - 1])
        @ temp = [$read($fileid)]
        if ( [$lineas] <= 30 ) xecho -win $winnum($0) $cparse("$temp") 
	if ( [$lineas] == 30 ) {
	  echo
	  exec echo "Última sesió oberta `cat /home/trunks/.BitchX/sunlite/logs/trunks.log | grep \"IRC log started\" | tail -n 1 | gawk '{ print $4 \" \" $6 \" \" $5 \" \" $8 \" a las \" $7}'`" } }

      if ( close($fileid) == -1 ) excho -win status $cparse("$Blanco¡¡¡ ERROR !!! tancant arxiu") }
    window logfile ~/.BitchX/sunlite/logs/$0.log log on
  } elsif ( ( winnum($0) != [-1] ) && ( [$0] != [] ) ) { 
    window swap $0 
  } {
    //query
    @ $winnam($winnum()) = 0
    if ( ( winnum() == 11 ) || ( ( winnum() == 12 ) && ( [$Partir] == 1) ) || ( winnum() == 1 ) )  {
      window name Cierrame log off
      clear 
    } {
      window kill }
    if ( [$Sonido] == 1 ) { exec bplay ~/.BitchX/sunlite/sonidos/cierraw.wav 2> /dev/null }
    if ( [$partir] == 1 ) {
      window hide_others
      usleep .5
      window swap $Pos3 
      usleep .5
      window show $Pos2
      window show $Pos1
      recolocar } } }
alias q query
if ( [$hotkey] == [ctrl] ) {
  bind ^z parse_command query
} elsif ( [$hotkey] == [alt] ) {
  bind META1-z parse_command query }
    
alias querys {
  if ( ( ( winnum() == 1 ) || ( winnum() == 2 ) ) && ( [$partir] == 1 ) ) {
    window goto $Principal }
  @ knal = [$0]
  window new server $0 hide swap last name $1 query $1 logfile ~/.BitchX/sunlite/logs/$1.log log on
  if ( [$partir] == 1 ) recolocar
  if ( [$Sonido] == 1 ) { exec bplay ~/.BitchX/sunlite/sonidos/abrew.wav 2> /dev/null } }

# Bueno, aquest bind ens serveix per anar-nos a la ultime finestra ;)
if ( [$hotkey] == [ctrl] ) {
  bind ^u SWAP_LAST_WINDOW
} elsif ( [$hotkey] == [alt] ) {
  bind META1-u SWAP_LAST_WINDOW }
    
# Netegem els bans que tinguem al canal actual si es q existeixen.
#
alias fban { 
  if (![$P] && [$C]) {
    opme
    on -mode 'CHaN $C +o $N' {
      mode $C -bbbb $N!*@* *!$my_ident@* *!*@$my_ip *!$my_ident@$my_ip } 
  } {
    mode $C -bbbb $N!*@* *!$my_ident@* *!*@$my_ip *!$my_ident@$my_ip } }

# Mode conferencia :)
#
alias Conferencia {
  if ( [$Conferencia] == 1 ) {
    @ Conferencia = 0
    @ Conf_canal = ""
  } {
    @ Conferencia = 1
    @ Conf_canal = [$C] } }
if ( [$hotkey] == [ctrl] ) {
  bind ^c parse_command Conferencia
} elsif ( [$hotkey] == [alt] ) {
  bind META1-c parse_command Conferencia }
    
# Una utilitat que ens servirà per enviar sms desde la nostra linia de 
# comandaments de BitchX
#
alias sms {
  if (( [$0] == "" ) || ( [$1] == "" )) {
    xecho -win status $cparse("Mode d'ús: /sms gateway nom texte")
    xecho -win status $cparse("Gateways suportats per esms: navegalia i movistar")
  } {
    exec echo $2- | esms -s $0 $1 } }

# Aquesta funció ens servirà d'acceés rapid a aquella finestra en la que el nostre 
# nick ha estat nombrat 
#
alias cambio_ventana {
  if ( ( ( winnum() == 1 ) || ( winnum() == 2 ) ) && ( [$Partir] == 1 ) ) {
    window goto $Principal }
  if ( [$Nick_en_canal] != "" && [$Nick_en_canal] != [$C] ) {
      window swap $Nick_en_canal
      @ Nick_en_canal = "" } }
if ( [$hotkey] == [ctrl] ) {
  bind ^x parse_command cambio_ventana
} elsif ( [$hotkey] == [alt] ) {
  bind META1-x parse_command cambio_ventana }
    
# Amb la instrucció /shell <password> mantindrem BX en segon plà mentres
# fem alguna operació que vulguem fer a la shell. Ens pot servir també
# en moments d'urgencia en que haguem de deixar el teclat lliure i no volem
# que algú llegeixi el que estem parlant ;) Per tornar a BX haurem de teclejar
# a la shell 'scr-bx -p' i a continuació indicarem la pass que vam definir 
# anteriorment 
#
alias shell {
  if ( [$0] != [] ) detach $0 }

# Bueno, pels amant del dibuixets, als q poc ens agraden yo que això és
# un script els incloëm uns aliases per fer figures ascii. Això si, necesites tindre
# instalats els paquets cowsay y figlet.
#
alias cowsay {
  switch ( $0 ) {
    ( normal ) { exec -o cowsay $1- }
    ( risa ) { exec -o cowsay -y $1- }
    ( tux ) { exec -o cowsay -f tux $1- }
    ( burla ) { exec -o cowsay -d $1- }
    ( susto ) { exec -o cowsay -w $1- }
    ( * ) {
      xecho -win status Mode d'ús: /cowsay {normal|burla|tux|susto} texte } } }

alias figlet {
  switch ( $0 ) {
    ( normal ) { exec -o figlet $1- }
    ( mini ) { exec -o figlet -f mini $1- }
    ( banner ) { exec -o figlet -f banner $1- }
    ( italic ) { exec -o figlet -f slant $1- }
    ( script ) { exec -o figlet -f script $1- }
    ( block ) { exec -o figlet -f block $1- }
    ( bubble ) { exec -o figlet -f bubble $1- }
    ( digital ) { exec -o figlet -f digital $1- }
    ( * ) {
      xecho -win status Mod d'ús: /figlet {normal|banner|mini|italic|script|block|bubble} texte } } }
	  
# Utilitcem el mpg123 com a reproductor de mp3 al nostre BitchX;) Els comandaments per
# utilitzar el reproductor són: 
#
#   /mp3 list 		-Llista el contingut de mp3 del directori que hem definit
#			com a Mp3dir.
#   /mp3 play RefNum|file	-Reprodueix l'arxiu de so especificat.
#   /mp3 stop		-Irrumpeix el procés de reproducció.
#   /mp3 dir ruta	-Assenyala una nova ruta per seleccionar els arxius
#			so.
#
alias mp3 {
  switch ( $0 ) {
    ( list ) {
      exec ls -1 -F $Mp3dir | gawk '{print "[" , NR, "]", $0}'
      xecho -win status $cparse("$Blanco\Per reproduïr: $AzulF\/mp3 play Refnum|Nom_arxiu") }
    ( play ) {
      @ RefNum = [$1]
      if ( [$1] == "" )  {
        xecho -win status $cparse("$Blanco\Indica un titul per tocar, ¿no? :)")
      } elsif ( isdigit($1) ) {
        exec mpg123 "$Mp3dir/`ls -1 $Mp3dir/ | head -n $RefNum | tail -n 1`" 2> /dev/null
        if ( [$Notif_mp3] == 1 ) {
	    exec -o  echo "Mmm... Toi escuchando `ls -1 $Mp3dir/ | head -n $RefNum | tail -n 1`" }
      } elsif ( [$1] == [\*] ) { 
        exec mpg123 $Mp3dir/\* 2> /dev/null
      } elsif ( [$1] == [\*/\*] ) {
        exec mpg123 $Mp3dir/\*/\* 2> /dev/null
      } {
        exec mpg123 "$Mp3dir/$RefNum" 2> /dev/null
        if ( [$Notif_mp3] == 1 ) {
	  exec -o  echo "Mmm... Toi escuchando `ls -1 $Mp3dir/ | grep $RefNum`" } } }
    ( stop ) {
      exec killall mpg123 2> /dev/null }
    ( dir ) {
      if ( [$1-] != "" ) {
        @ Mp3dir = [$1-]
      } {
        xecho -win status $cparse("$Blanco\El directori de mp3's és [$Mp3dir]. Si vols cambiarlo tecleja: $AzulF\/mp3 dir path") } }
    ( * ) {
      xecho -win status $cparse("$Blanco\Mode d'us: $AzulF\/mp3 {list|play|stop|dir}") } } }

# Utilitzem el cdcd com a reproductor de cd's al nostre BitchX ;) Les comandaments per a
# utilitzar el reproductor són:
#
#   /cd list           -llista el contingut de pistes del Cd.
#   /cd play RefNum    -Reprodueix la pista especificada.
#   /cd stop           -Irrumpeix el procés de reproducció.
#   /cd refresh        -Refresca llistat de reproducció.
#
alias cd {
  switch ( $0 ) {
    ( list ) { 
      exec cdcd tracks }
    ( play ) {
      @ RefNum = [$1]
      if ( isdigit($1) ) {
        exec cdcd play $RefNum
        @ RefNum = ([$RefNum] + 6)
        if ( [$Notif_mp3] == 1 ) {
          exec -o echo "Mmm... estic escoltant `cdcd tracks | grep \"Album artist\" | cut -c 17-`: `cdcd tracks | head -n $RefNum | tail -n 1 | cut -c 21-`" }       
      } elsif ( [$RefNum] == [\*] ) {
        exec cdcd rndplay 
      } {
        xecho -win status $cparse("$Blanco\Mode d'ús: $Azulf\/cd {list|play RefNum|stop|refresh}") } }
    ( stop ) { 
      exec cdcd stop }
    ( refresh ) { 
      exec cdcd refresh }
    ( * ) { 
      xecho -win status $cparse("$Blanco\Mode d'ús: $Azulf\/cd {list|play|stop|refresh}") } } }

# Definim una nova versió per l'script on afegim la resenya de l'script
# a la de BitchX
#
alias version {
  //version
  echo $cparse("$RojoF-$Blanco:$RojoF-") $J }

# Coloraines pel nostre BitchX
#
alias color {
  if ( ( [$0] == [si] ) || ( [$0] == [sí] ) || ( [$VerdeF] == [] ) ) {
    if ( [$theme] == [bass] ) {
      @ VerdeF = [%g]
      @ Blanco = [%c]
      @ Amarillo = [%B]
      @ Magenta = [%Y]
      @ Violeta = [%c]
      @ Verde = [%g]
      @ RojoF = [%r]
      @ Rojo = [%r]
      @ AzulF = [%B]
      @ Gris = [%w]
      @ Naranja = [%b]
      @ CyanF = [%C]
      @ Cyan = [%c]
      set mircs on
    } {
      @ VerdeF = [%G]
      @ Verde = [%g]
      @ RojoF = [%R]
      @ Rojo = [%r]
      @ AzulF = [%B]
      @ Blanco = [%W]
      @ Gris = [%w]
      @ Amarillo = [%Y]
      @ Naranja = [%y]
      @ Magenta = [%M]
      @ Violeta = [%m]
      @ CyanF = [%C]
      @ Cyan = [%c]
      set mircs on }
  } {
    @ VerdeF = []
    @ Verde = []
    @ RojoF = []
    @ Rojo = []
    @ AzulF = []
    @ Blanco = []
    @ Gris = []
    @ Amarillo = []
    @ Naranja = []
    @ Magenta = []
    @ Violeta = []
    @ CyanF = []
    @ Cyan = [] 
    set mircs off } }

alias sonido {
  if ( ( [$0] == [si] ) || ( [$0] == [sí]) || ( [$Sonido] == 0 ) || ( [$0] == [on] ) ) {
    set beep on
    @ Sonido = 1
  } {
    set beep off
    @ Sonido = 0 } }

# Códi genera per L00PB4cK i modificat per {Trunks}
#
# Identificació de nick des de un arxiu amb passwords encriptades
#
alias identifica { 
  if ( [$0] != "" ) {
    @ NNick = [$0]
  } {
    @ NNick = [$N] }
  if ($fexist(~/.BitchX/sunlite/passwd.bx) != -1) {
    @ fileid = [$open(~/.BitchX/sunlite/passwd.bx R)]
    @ findid = 0
    while ( ( eof($fileid) == 0) && ( $findid != 1) ) {
      @ temp = [$read($fileid)]
      @ temp1 = [$decode($temp)]
      @ nickid = [$midw(0 1 $temp1)]
      @ passid = [$midw(1 1 $temp1)]
      @ net = [$midw(2 1 $temp1)]
      if (( [$NNick] == [$nickid] ) && ( [$findid] == 0 )) {
        if ( ( match(hispano $reverse($mid(4 7 $reverse($net)))) >= 1) && ( match(hispano $reverse($mid(4 7 $reverse($servername($winserv()))))) >= 1 )) {
          msg nick@deep.space identify $passid
          quote nick $NNick:$passid
          @ findid = 1
        } elsif ( ( match(openprojects $reverse($mid(4 12 $reverse($net)))) >= 1 ) && ( match(openprojects $reverse($mid(4 12 $reverse($servername($winserv()))))) >= 1 )) {
          //nick $NNick
          msg nickserv identify $passid
          @ findid = 1
        } elsif ( ( match(dal $reverse($mid(4 3 $reverse($net)))) >= 1 ) && ( match(dal $reverse($mid(4 3 $reverse($servername($winserv()))))) >= 1 )) {
          //nick $NNick
          msg nickserv@services.dal.net identify $passid
          @ findid = 1 } } }
    if ( close($fileid) == -1) {
      xecho -win status $cparse("$Blanco!!!$RojoF ERROR $Blanco!!!$Verde tancant la base de dades") }
    if ([$findid] == 0) {
      input "$cparse("%RIntrodueixi password per $NNick: ")" {
        if ( [$0] != "" ) {
          @ passid = [$0]
        @ fileid = [$open(~/.BitchX/sunlite/passwd.bx R)]
        while ( ( eof($fileid) == 0) && ( $findid != 1 ) ) {
          @ temp = [$read($fileid)]
          @ temp1 = [$decode($temp)]
          @ nickid = [$midw(0 1 $temp1)]
          @ net = [$midw(2 1 $temp1)]
          if ([$NNick] == [$nickid]) {
            if ( ( servername($winserv()) == match($net $reverse($mid(4 7 $reverse($servername($winserv()))))) || servername($winserv()) == match($net $reverse($mid(4 3 $reverse($servername($winserv()))))) || servername($winserv()) == match($net $reverse($mid(4 12 $reverse($servername($winserv()))))))) {
              @ find = 1 } } }
        if ( close($fileid) == 1) {
          xecho -win status $cparse("$Verde\Error tancant l'arxiu") }
        if ( [$find] == 1 ) {
          xecho -win status $cparse("$Verde\El nick $1 ja està inclòs a la base de dades sota la xarxa $3")
        } {
          @ fileid = [$open(~/.BitchX/sunlite/passwd.bx W)]
          @ temp2 = [$NNick] ## [ ] ## [$passid] ## [ ] ## [$servername($winserv())]
          @ encoded = [$encode($temp2)]
          if ( write($fileid $encoded) == -1) {
            xecho -win status $cparse("$Verde\Escrivint a l'arxiu")
          } {
            xecho -win status $cparse("$Verde\Dades escrites correctament a l'arxiu") 
            identifica $NNick }
          if ( close($fileid) == 1) {
            xecho -win status $cparse("$Verde\Error tancant arxiu") } } } } } } }

# Un nou comandament per alternar el nostre nick al marcarnos com a away
# Idea original de |Poldark| He modifica una mica el seu desenvolupament original més
# que res aprofitant aliases ja disenyats a l'script.
alias awayon {
  nick $nick_awayOn
  deopme
  away $0- }

alias awayoff {
  nick $nick_awayOff
  if ( ! [$P] && [$C] ) {
    on -nickname '$N' opme }
  away
  if ( [$0] != "" ) {
    me $0- } }

# Missatge de sortida personalitzat per l'script
#
alias quit {
  if ( [$0] == "" ) {
    //quit $Msg_quit
  } {
    //quit $0- } }

# Aquest alias ens servirà per enviar una cadena a alguna terminal d'X ;) Molt útil 
# quan ens trobem en una tty i necesitem portar una url a un navegador
# per exemple ;)
#
# - Gracies a Poldark per la seva idea ;) -
#
alias termX {
  exec echo '$0-' > /dev/`ps u | grep pts | head -n1 | gawk '{print $7}'` }

# Afegirem un traductor per aquelles vegades que ens dona per xatejar a canals
# extrangers i no ens enrecordem del significat exacte de la parauleta en questió ;)
#
# Mode d'ús: /traducir [inglés|ingles|english|español|spanish] paraula ( sense argument
# tradueix per defecte de l'anglés a l'espanyol )
#
alias traducir {
  if ( [$0] == "" ) {
    xecho -win status $cparse("$Blanco\Mode d'ús: $AzulF/traducir [ingles|inglés|english|español|spanish] paraula \( Per defecte traduïrà as castellà una paraula en anglés \)")
  } elsif ( ( [$0] == [inglés] ) || ( [$0] == [ingles] ) || ( [$0] == [english] ) ) { 
    exec i2e.sh -re $1
  } elsif ( ( [$0] == [español] ) || ( [$0] == [spanish] ) ) {
    exec i2e.sh -e $1
  } {
    exec i2e.sh -e $0 } }
alias translate traducir

# Aquest alias et servirà per posar totes les finestres en ordre si en algún 
# moment veus que l'script falla i se't descol·loca tot el teu sistema de finestretes
#
alias recolocar {
  switch ( $Pos1 ) {
    ( 11 ) {
      switch ( $Pos2 ) {
        ( 12 ) {
          window goto 1
          window size 5
          window goto 2
          window size 7
          window goto 3 }
        ( 1 ) {
          window goto 3
          window size 7
          window goto 1
          window size 5
          window goto 2 } } }
    ( 12 ) {
      switch ( $Pos2 ) {
        ( 11 ) {
          window goto 1
          window size 7
          window goto 2
          window size 5
          window goto 3 }
        ( 1 ) {
          window goto 3
          window size 5
          window goto 1
          window size 7
          window goto 2 } } }
    ( 1 ) {
      switch ( $Pos2 ) {
        ( 11 ) {
          window goto 2
          window size 5
          window goto 3
          window size 7
          window goto 1 }
        ( 12 ) {
          window goto 2
          window size 7
          window goto 3
          window size 5
          window goto 1 } } } } }

# Aquí van un parell de hot-keys: Per moure'ns per les finestres si utilitzem la funció
# de finestres partides, i dos o més per navegar d'esquerra a dreta per les 
# finestres ;)
#
if ( [$hotkey] == [alt] ) {
  bind META1-q NEXT_WINDOW
  bind META1-w SWAP_PREVIOUS_WINDOW
  bind META1-e SWAP_NEXT_WINDOW
  bind META1-n notify
} elsif ( [$hotkey] == [ctrl] ) {
  bind ^q NEXT_WINDOW
  bind ^w SWAP_PREVIOUS_WINDOW
  bind ^e SWAP_NEXT_WINDOW 
  bind ^n notify }

bind META32-~ beginning_of_line
bind META33-~ end_of_line
bind META1-, beginning_of_line
bind META1-. end_of_line

# Copyright © 2002 Javier Carranza
